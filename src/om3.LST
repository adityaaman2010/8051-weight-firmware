C51 COMPILER V9.60.0.0   OM3                                                               09/28/2022 12:09:02 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OM3
OBJECT MODULE PLACED IN om3.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE om3.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <stdio.h>
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "REG_MG82FG5Bxx.H"
   5          #include "macro.h"
   6          #include "utility.h"
   7          #include "tm1640.h"
   8          #include "keypad.h"
   9          #include "weight.h"
  10          
  11          
  12          
  13          void key_display(void);
  14          void Keypad_GPIO_Config(void);
  15          void handleModeOne(void);
  16          void key_sort(unsigned char);
  17          unsigned char* getCharArray(int);
  18          unsigned char* getNumberDisplayFloat(float, int, int);
  19          void initializeDisplay();
  20          
  21          unsigned char xdata hi_key_no, lo_key_no;
  22          unsigned char xdata overflowHex[] = {0x10, 0x10, 0x10, 0x10, 0x10, 0x10};
  23          unsigned char xdata no_digits[] = {0xed,0xa0,0xd9,0xf8,0xb4,0x7c,0x7d,0xe0,0xfd,0xfc};  //0,1,2,3,4,5,6,7,8
             -,9
  24          unsigned char xdata digi_chk[] = {0x40,0xc0,0xe0,0xe8,0xe9,0xed,0xfd};
  25          unsigned char xdata prc[] = {0x00, 0x4d,0x45, 0xd5, 0x00};
  26          unsigned char xdata ver[] = { 0xed, 0xa2,0x00,0x45,0x5d, 0xad};
  27          unsigned char xdata compny_name[] = { 0xb5, 0x5d,0x0d, 0x0d, 0xed, 0x10, 0x7c, 0x4d, 0xf5,0x0d,0x00,0x00,0
             -x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  28          unsigned char xdata blank_L[] = { 0x00,0x00,0x00,0x00,0x00,0x00};
  29          unsigned char xdata bat_digi[] = { 0x00,0x1d, 0xf5, 0xfd,0x00};
  30          unsigned char xdata bat_voltg[] = { 0xb4,0xa2, 0xa0, 0x00,0x00};
  31          unsigned char xdata final_display[7];
  32          // flag to check if decimal mode activated
  33          int xdata isDecimal = 0,afterDecimal = 0;
  34          int xdata precision = 2;
  35          float xdata weight, total, currentPrice;
  36          int xdata isOverflow = 0;
  37          unsigned char xdata key, inputPrice[7], temp[1];
  38          unsigned char* xdata output;
  39          
  40          
  41          void main(void)
  42          {
  43   1          initializeDisplay();
  44   1          while(1)
  45   1          {
  46   2              weight = getWeight();
  47   2              output = getNumberDisplayFloat(weight, 5, precision);
  48   2              TM1640_U_display(output);
  49   2              key = scan_keypad();
  50   2              Delay_Some_Time(10);
  51   2              if(key != 'A') {
  52   3                  isOverflow = (isDecimal == 1 && strlen(inputPrice) < 6) || ((isDecimal == 0 && strlen(inputPri
             -ce) + precision < 6) && key == 10) || (isDecimal == 0 && strlen(inputPrice) + precision < 5) ? 0 : 1;
C51 COMPILER V9.60.0.0   OM3                                                               09/28/2022 12:09:02 PAGE 2   

  53   3                  if ((key < 11 && isOverflow == 0) || key == 11)
  54   3                  {
  55   4                       handleModeOne();
  56   4                  }
  57   3              }
  58   2              Delay_Some_Time(10);
  59   2          }
  60   1          
  61   1      }
  62          
  63          void handleModeOne(void)
  64          {
  65   1          if(key == 11)
  66   1          {
  67   2              inputPrice[0] = '\0';
  68   2              isDecimal = 0;
  69   2              afterDecimal = 0;
  70   2              currentPrice = 0.0;
  71   2          }
  72   1          else if (key < 10 &&  isDecimal == 0)
  73   1          {
  74   2              key = 0x30 | key;
  75   2              temp[0] = key;
  76   2              joinCharacter(inputPrice, temp);
  77   2              currentPrice = atof(inputPrice);
  78   2          }
  79   1          else if (key == 10 && isDecimal == 0)
  80   1          {
  81   2              isDecimal = 1;
  82   2              return;
  83   2          }
  84   1          else if (key < 10 &&  isDecimal == 1 && afterDecimal == 0)
  85   1          {
  86   2              // first number pressed after "."
  87   2              temp[0] = '.';
  88   2              joinCharacter(inputPrice, temp);
  89   2              key = 0x30 | key;
  90   2              temp[0] = key;
  91   2              joinCharacter(inputPrice, temp);
  92   2              afterDecimal = 1;
  93   2              currentPrice = atof(inputPrice);
  94   2          }
  95   1          else if (key < 10 &&  isDecimal == 1 && afterDecimal == 1)
  96   1          {
  97   2              key = 0x30 | key;
  98   2              temp[0] = key;
  99   2              joinCharacter(inputPrice, temp);
 100   2              currentPrice = atof(inputPrice);
 101   2          }
 102   1          total = currentPrice * weight;
 103   1          output = getNumberDisplayFloat(currentPrice,5, precision);
 104   1          TM1640_M_display(output);
 105   1          output = getNumberDisplayFloat(total, 6, precision);
 106   1          TM1640_L_display(output);
 107   1      }
 108          
 109          void Keypad_GPIO_Config(void)
 110          {
 111   1          P1M0 = 0x1f;
 112   1          P22 = 1;
 113   1          P24 = 1;
 114   1          P26 = 1;
C51 COMPILER V9.60.0.0   OM3                                                               09/28/2022 12:09:02 PAGE 3   

 115   1          P16 = 1;
 116   1          P15 = 1;
 117   1          P10 = 0;
 118   1          P11 = 0;
 119   1          P12 = 0;
 120   1          P13 = 0;
 121   1          P14 = 0;
 122   1          
 123   1      }
 124          
 125          unsigned char* getNumberDisplayFloat(float x, int displayLength, int precision)
 126          {
 127   1          unsigned char value[8];
 128   1          unsigned char t[8];
 129   1          int value_len = 0;
 130   1          int set_flag = 0;
 131   1          int after_display = 0;
 132   1          int y, i, index;
 133   1          unsigned char a;
 134   1          if (precision == 0)
 135   1          {
 136   2              sprintf(value, "%.0f", x);
 137   2          }
 138   1          else if (precision == 1)
 139   1          {
 140   2              sprintf(value, "%.1f", x);
 141   2          }
 142   1          else if (precision == 2)
 143   1          {
 144   2              sprintf(value, "%.2f", x);
 145   2          }
 146   1          else if (precision == 3)
 147   1          {
 148   2              sprintf(value, "%.3f", x);
 149   2          }
 150   1          for(i=0; i<strlen(value);i++)
 151   1          {
 152   2              if(value[i] == '.'){
 153   3                  break;
 154   3              }
 155   2              else{
 156   3                  value_len++;
 157   3              }
 158   2          }
 159   1          if((value_len + precision) > (displayLength))
 160   1          {
 161   2              // Display out of bound values on display
 162   2              return overflowHex;
 163   2          }
 164   1      
 165   1          for (i= strlen(value) - 1; i > -1; i--)
 166   1          {
 167   2              y = strlen(value) - 1 - i;
 168   2              t[y] = value[i];
 169   2          }
 170   1          t[strlen(value)] = '\0';
 171   1          for(i=0;i < displayLength; i++)
 172   1          {
 173   2              final_display[i] = BLANK_HEX;
 174   2          }
 175   1          for(i=0;i < strlen(t); i++)
 176   1          {
C51 COMPILER V9.60.0.0   OM3                                                               09/28/2022 12:09:02 PAGE 4   

 177   2              if(t[i]  == '.')
 178   2              {
 179   3                  set_flag = 1;
 180   3                  after_display = 1;
 181   3                  continue;
 182   3              }
 183   2              index = t[i] & 0x0f;
 184   2              a = no_digits[index];
 185   2              if(after_display == 1)
 186   2              {
 187   3                  if (set_flag == 1)
 188   3                  {
 189   4                      a = 0x02 | a;
 190   4                      final_display[i-1] = a;
 191   4                      set_flag = 0;
 192   4                  }
 193   3                  else
 194   3                  {
 195   4                      final_display[i-1] = a;
 196   4                  }
 197   3              }
 198   2              else
 199   2              {
 200   3                  final_display[i] = a;
 201   3              }
 202   2              
 203   2          }
 204   1          return final_display;
 205   1      }
 206          
 207          //void key_display(void)
 208          //{
 209          //    unsigned char temp[6];
 210          //    temp[0] = lo_key_no;
 211          //    temp[1] = hi_key_no;
 212          //    temp[2] = BLANK_HEX;
 213          //    temp[3] = BLANK_HEX;
 214          //    temp[4] = BLANK_HEX;
 215          //    temp[5] = BLANK_HEX;
 216          //    TM1640_L_display(temp);
 217          //
 218          //}
 219          //void key_sort(unsigned char temp_key)
 220          //{
 221          //    if(temp_key <10)
 222          //    {
 223          //        hi_key_no = 0;
 224          //        lo_key_no = temp_key;
 225          //    }
 226          //    else
 227          //    {
 228          //        hi_key_no = temp_key/10;
 229          //        lo_key_no = temp_key%10;
 230          //    }
 231          //    hi_key_no = no_digits[hi_key_no];
 232          //    lo_key_no = no_digits[lo_key_no];
 233          //}
 234          
 235          void initializeDisplay()
 236          {
 237   1          TM1640_GPIO_Config();
 238   1          Keypad_GPIO_Config();
C51 COMPILER V9.60.0.0   OM3                                                               09/28/2022 12:09:02 PAGE 5   

 239   1          TM1640_Init(DSPTM1640_DIS);     //TM1640 initialization
 240   1          Delay_Some_Time(10 );
 241   1      
 242   1          TM1640_U_display(blank_L);
 243   1          TM1640_M_display(blank_L);
 244   1          TM1640_L_display(blank_L);
 245   1      
 246   1          TM1640_U_display(prc);
 247   1          ldelay();
 248   1      
 249   1          TM1640_L_display(ver);
 250   1          ldelay();
 251   1      
 252   1          TM1640_L_display(blank_L);
 253   1          TM1640_U_display(blank_L);
 254   1          TM1640_M_display(blank_L);
 255   1          ldelay();
 256   1      
 257   1          TM1640_UM_display(compny_name);
 258   1          ldelay();
 259   1      
 260   1          TM1640_digichk(digi_chk);
 261   1          ldelay();
 262   1      
 263   1          TM1640_L_display(blank_L);
 264   1          TM1640_U_display(blank_L);
 265   1          TM1640_M_display(blank_L);
 266   1          ldelay();
 267   1          ldelay();
 268   1      
 269   1          output = getNumberDisplayFloat(0, 5, 2);
 270   1          TM1640_M_display(output);
 271   1          output = getNumberDisplayFloat(0, 6, precision);
 272   1          TM1640_L_display(output);
 273   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1406    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =    111    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      32
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
