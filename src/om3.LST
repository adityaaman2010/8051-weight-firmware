C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 01:40:39 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OM3
OBJECT MODULE PLACED IN om3.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE om3.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <stdio.h>
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "REG_MG82FG5Bxx.H"
   5          #include "macro.h"
   6          #include "utility.h"
   7          #include "tm1640.h"
   8          #include "keypad.h"
   9          #include "weight.h"
  10          
  11          
  12          
  13          void key_display(void);
  14          void Keypad_GPIO_Config(void);
  15          void key_sort(unsigned char);
  16          unsigned char* getCharArray(int);
  17          unsigned char* getNumberDisplayFloat(float, int, int);
  18          void initializeDisplay();
  19          
  20          unsigned char hi_key_no, lo_key_no;
  21          unsigned char xdata overflowHex[] = {0x10, 0x10, 0x10, 0x10, 0x10, 0x10};
  22          unsigned char xdata no_digits[] = {0xed,0xa0,0xd9,0xf8,0xb4,0x7c,0x7d,0xe0,0xfd,0xfc};  //0,1,2,3,4,5,6,7,8
             -,9
  23          unsigned char xdata digi_chk[] = {0x40,0xc0,0xe0,0xe8,0xe9,0xed,0xfd};
  24          unsigned char xdata prc[] = {0x00, 0x4d,0x45, 0xd5, 0x00};
  25          unsigned char xdata ver[] = { 0xed, 0xa2,0x00,0x45,0x5d, 0xad};
  26          unsigned char xdata compny_name[] = { 0xb5, 0x5d,0x0d, 0x0d, 0xed, 0x10, 0x7c, 0x4d, 0xf5,0x0d,0x00,0x00,0
             -x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  27          unsigned char xdata blank_L[] = { 0x00,0x00,0x00,0x00,0x00,0x00};
  28          unsigned char xdata bat_digi[] = { 0x00,0x1d, 0xf5, 0xfd,0x00};
  29          unsigned char xdata bat_voltg[] = { 0xb4,0xa2, 0xa0, 0x00,0x00};
  30          unsigned char xdata final_display[7];
  31          // flag to check if decimal mode activated
  32          int isDecimal = 0,afterDecimal = 0;
  33          int xdata precision = 2;
  34          
  35          
  36          void main(void)
  37          {
  38   1          float xdata weight, total, currentPrice;
  39   1          int isOverflow = 0;
  40   1          unsigned char key, inputPrice[7], temp[1];
  41   1          unsigned char* output;
  42   1          initializeDisplay();
  43   1          output = getNumberDisplayFloat(0, 5, 2);
  44   1          TM1640_M_display(output);
  45   1          output = getNumberDisplayFloat(0, 6, precision);
  46   1          TM1640_L_display(output);
  47   1          while(1)
  48   1          {
  49   2              weight = getWeight();
  50   2              output = getNumberDisplayFloat(weight, 5, precision);
  51   2              TM1640_U_display(output);
  52   2              key = scan_keypad();
  53   2              Delay_Some_Time(10);
C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 01:40:39 PAGE 2   

  54   2              if(key != 'A') {
  55   3                  isOverflow = (isDecimal == 1 && strlen(inputPrice) < 6) || ((isDecimal == 0 && strlen(inputPri
             -ce) + precision < 6) && key == 10) || (isDecimal == 0 && strlen(inputPrice) + precision < 5) ? 0 : 1;
  56   3                  if ((key < 11 && isOverflow == 0) || key == 11)
  57   3                  {
  58   4                       if(key == 11)
  59   4                       {
  60   5                           inputPrice[0] = '0';
  61   5                           inputPrice[1] = '\0';
  62   5                           isDecimal = 0;
  63   5                           afterDecimal = 0;
  64   5                       }
  65   4                       else if (key < 10 &&  isDecimal == 0)
  66   4                       {
  67   5                          key = 0x30 | key;
  68   5                          temp[0] = key;
  69   5                          joinCharacter(inputPrice, temp);
  70   5                      }
  71   4                       else if (key == 10 && isDecimal == 0)
  72   4                       {
  73   5                          isDecimal = 1;
  74   5                          continue;
  75   5                      }
  76   4                       else if (key < 10 &&  isDecimal == 1 && afterDecimal == 0)
  77   4                       {
  78   5                          // first number pressed after "."
  79   5                          temp[0] = '.';
  80   5                          joinCharacter(inputPrice, temp);
  81   5                          key = 0x30 | key;
  82   5                          temp[0] = key;
  83   5                          joinCharacter(inputPrice, temp);
  84   5                          afterDecimal = 1;
  85   5                      }
  86   4                       else if (key < 10 &&  isDecimal == 1 && afterDecimal == 1)
  87   4                       {
  88   5                          key = 0x30 | key;
  89   5                          temp[0] = key;
  90   5                          joinCharacter(inputPrice, temp);
  91   5                      }
  92   4                      currentPrice = atof(inputPrice);
  93   4                      total = currentPrice * weight;
  94   4                      output = getNumberDisplayFloat(currentPrice,5, precision);
  95   4                      TM1640_M_display(output);
  96   4                      output = getNumberDisplayFloat(total, 6, precision);
  97   4                      TM1640_L_display(output);
  98   4                  }
  99   3              }
 100   2              Delay_Some_Time(10);
 101   2          }
 102   1          
 103   1      }
 104          void Keypad_GPIO_Config(void)
 105          {
 106   1          P1M0 = 0x1f;
 107   1          P22 = 1;
 108   1          P24 = 1;
 109   1          P26 = 1;
 110   1          P16 = 1;
 111   1          P15 = 1;
 112   1          P10 = 0;
 113   1          P11 = 0;
 114   1          P12 = 0;
C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 01:40:39 PAGE 3   

 115   1          P13 = 0;
 116   1          P14 = 0;
 117   1          
 118   1      }
 119          
 120          unsigned char* getNumberDisplayFloat(float x, int displayLength, int precision)
 121          {
 122   1          unsigned char value[8];
 123   1          unsigned char t[8];
 124   1          int value_len = 0;
 125   1          int set_flag = 0;
 126   1          int after_display = 0;
 127   1          int y, i, index;
 128   1          unsigned char a;
 129   1          if (precision == 0)
 130   1          {
 131   2              sprintf(value, "%.0f", x);
 132   2          }
 133   1          else if (precision == 1)
 134   1          {
 135   2              sprintf(value, "%.1f", x);
 136   2          }
 137   1          else if (precision == 2)
 138   1          {
 139   2              sprintf(value, "%.2f", x);
 140   2          }
 141   1          else if (precision == 3)
 142   1          {
 143   2              sprintf(value, "%.3f", x);
 144   2          }
 145   1          for(i=0; i<strlen(value);i++)
 146   1          {
 147   2              if(value[i] == '.'){
 148   3                  break;
 149   3              }
 150   2              else{
 151   3                  value_len++;
 152   3              }
 153   2          }
 154   1          if((value_len + precision) > (displayLength))
 155   1          {
 156   2              // Display out of bound values on display
 157   2              return overflowHex;
 158   2          }
 159   1      
 160   1          for (i= strlen(value) - 1; i > -1; i--)
 161   1          {
 162   2              y = strlen(value) - 1 - i;
 163   2              t[y] = value[i];
 164   2          }
 165   1          t[strlen(value)] = '\0';
 166   1          for(i=0;i < displayLength; i++)
 167   1          {
 168   2              final_display[i] = BLANK_HEX;
 169   2          }
 170   1          for(i=0;i < strlen(t); i++)
 171   1          {
 172   2              if(t[i]  == '.')
 173   2              {
 174   3                  set_flag = 1;
 175   3                  after_display = 1;
 176   3                  continue;
C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 01:40:39 PAGE 4   

 177   3              }
 178   2              index = t[i] & 0x0f;
 179   2              a = no_digits[index];
 180   2              if(after_display == 1)
 181   2              {
 182   3                  if (set_flag == 1)
 183   3                  {
 184   4                      a = 0x02 | a;
 185   4                      final_display[i-1] = a;
 186   4                      set_flag = 0;
 187   4                  }
 188   3                  else
 189   3                  {
 190   4                      final_display[i-1] = a;
 191   4                  }
 192   3              }
 193   2              else
 194   2              {
 195   3                  final_display[i] = a;
 196   3              }
 197   2              
 198   2          }
 199   1          return final_display;
 200   1      }
 201          
 202          //void key_display(void)
 203          //{
 204          //    unsigned char temp[6];
 205          //    temp[0] = lo_key_no;
 206          //    temp[1] = hi_key_no;
 207          //    temp[2] = BLANK_HEX;
 208          //    temp[3] = BLANK_HEX;
 209          //    temp[4] = BLANK_HEX;
 210          //    temp[5] = BLANK_HEX;
 211          //    TM1640_L_display(temp);
 212          //
 213          //}
 214          //void key_sort(unsigned char temp_key)
 215          //{
 216          //    if(temp_key <10)
 217          //    {
 218          //        hi_key_no = 0;
 219          //        lo_key_no = temp_key;
 220          //    }
 221          //    else
 222          //    {
 223          //        hi_key_no = temp_key/10;
 224          //        lo_key_no = temp_key%10;
 225          //    }
 226          //    hi_key_no = no_digits[hi_key_no];
 227          //    lo_key_no = no_digits[lo_key_no];
 228          //}
 229          
 230          void initializeDisplay()
 231          {
 232   1          TM1640_GPIO_Config();
 233   1          Keypad_GPIO_Config();
 234   1          TM1640_Init(DSPTM1640_DIS);     //TM1640 initialization
 235   1          Delay_Some_Time(10 );
 236   1      
 237   1          TM1640_U_display(blank_L);
 238   1          TM1640_M_display(blank_L);
C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 01:40:39 PAGE 5   

 239   1          TM1640_L_display(blank_L);
 240   1      
 241   1          TM1640_U_display(prc);
 242   1          ldelay();
 243   1      
 244   1          TM1640_L_display(ver);
 245   1          ldelay();
 246   1      
 247   1          TM1640_L_display(blank_L);
 248   1          TM1640_U_display(blank_L);
 249   1          TM1640_M_display(blank_L);
 250   1          ldelay();
 251   1      
 252   1          TM1640_UM_display(compny_name);
 253   1          ldelay();
 254   1      
 255   1          TM1640_digichk(digi_chk);
 256   1          ldelay();
 257   1      
 258   1          TM1640_L_display(blank_L);
 259   1          TM1640_U_display(blank_L);
 260   1          TM1640_M_display(blank_L);
 261   1          ldelay();
 262   1          ldelay();
 263   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1281    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     79      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      46
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
