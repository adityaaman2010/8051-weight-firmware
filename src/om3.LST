C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 00:55:44 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OM3
OBJECT MODULE PLACED IN om3.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE om3.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <stdio.h>
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "REG_MG82FG5Bxx.H"
   5          #include "macro.h"
   6          #include "utility.h"
   7          #include "tm1640.h"
   8          #include "keypad.h"
   9          #include "weight.h"
  10          
  11          
  12          
  13          void key_display(void);
  14          void Keypad_GPIO_Config(void);
  15          void key_sort(unsigned char);
  16          unsigned char* getCharArray(int);
  17          unsigned char* getNumberDisplayFloat(float, int, int);
  18          void initializeDisplay();
  19          void joinCharacter(unsigned char*, unsigned char*);
  20          
  21          unsigned char hi_key_no, lo_key_no;
  22          unsigned char xdata overflowHex[] = {0x10, 0x10, 0x10, 0x10, 0x10, 0x10};
  23          unsigned char xdata no_digits[] = {0xed,0xa0,0xd9,0xf8,0xb4,0x7c,0x7d,0xe0,0xfd,0xfc};  //0,1,2,3,4,5,6,7,8
             -,9
  24          unsigned char xdata digi_chk[] = {0x40,0xc0,0xe0,0xe8,0xe9,0xed,0xfd};
  25          unsigned char xdata prc[] = {0x00, 0x4d,0x45, 0xd5, 0x00};
  26          unsigned char xdata ver[] = { 0xed, 0xa2,0x00,0x45,0x5d, 0xad};
  27          unsigned char xdata compny_name[] = { 0xb5, 0x5d,0x0d, 0x0d, 0xed, 0x10, 0x7c, 0x4d, 0xf5,0x0d,0x00,0x00,0
             -x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  28          unsigned char xdata blank_L[] = { 0x00,0x00,0x00,0x00,0x00,0x00};
  29          unsigned char xdata bat_digi[] = { 0x00,0x1d, 0xf5, 0xfd,0x00};
  30          unsigned char xdata bat_voltg[] = { 0xb4,0xa2, 0xa0, 0x00,0x00};
  31          unsigned char xdata final_display[7];
  32          // flag to check if decimal mode activated
  33          int isDecimal = 0;
  34          int afterDecimal = 0;
  35          int xdata precision = 2;
  36          
  37          
  38          void main(void) {
  39   1          float xdata x, weight, total, currentPrice;
  40   1          int isOverflow = 0;
  41   1          unsigned char key, inputPrice[7], temp[1];
  42   1          unsigned char* output;
  43   1          initializeDisplay();
  44   1          output = getNumberDisplayFloat(0, 5, 2);
  45   1          TM1640_M_display(output);
  46   1          output = getNumberDisplayFloat(0, 6, precision);
  47   1          TM1640_L_display(output);
  48   1          while(1) {
  49   2              weight = getWeight();
  50   2              output = getNumberDisplayFloat(weight, 5, precision);
  51   2              TM1640_U_display(output);
  52   2              key = scan_keypad();
  53   2              Delay_Some_Time(10);
C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 00:55:44 PAGE 2   

  54   2              if(key != 'A') {
  55   3                  isOverflow = (isDecimal == 1 && strlen(inputPrice) < 6) || ((isDecimal == 0 && strlen(inputPri
             -ce) + precision < 5) && key != 10) ? 0 : 1;
  56   3                  if (key < 11 && isOverflow == 0) {
  57   4                      if (key < 10 &&  isDecimal == 0) {
  58   5                          key = 0x30 | key;
  59   5                          temp[0] = key;
  60   5                          joinCharacter(inputPrice, temp);
  61   5                      }else if (key == 10 && isDecimal == 0) {
  62   5                          isDecimal = 1;
  63   5                          continue;
  64   5                      }else if (key < 10 &&  isDecimal == 1 && afterDecimal == 0) {
  65   5                          // first number pressed after "."
  66   5                          temp[0] = '.';
  67   5                          joinCharacter(inputPrice, temp);
  68   5                          key = 0x30 | key;
  69   5                          temp[0] = key;
  70   5                          joinCharacter(inputPrice, temp);
  71   5                          afterDecimal = 1;
  72   5                      }else if (key < 10 &&  isDecimal == 1 && afterDecimal == 1) {
  73   5                          key = 0x30 | key;
  74   5                          temp[0] = key;
  75   5                          joinCharacter(inputPrice, temp);
  76   5                      }
  77   4                      currentPrice = atof(inputPrice);
  78   4                      total = currentPrice * weight;
  79   4                      output = getNumberDisplayFloat(currentPrice,5, precision);
  80   4                      TM1640_M_display(output);
  81   4                      output = getNumberDisplayFloat(total, 6, precision);
  82   4                      TM1640_L_display(output);
  83   4                  }
  84   3              }
  85   2              Delay_Some_Time(10);
  86   2          }
  87   1          
  88   1      }
*** WARNING C280 IN LINE 39 OF om3.c: 'x': unreferenced local variable
  89          void Keypad_GPIO_Config(void)
  90          {
  91   1          P1M0 = 0x1f;
  92   1          P22 = 1;
  93   1          P24 = 1;
  94   1          P26 = 1;
  95   1          P16 = 1;
  96   1          P15 = 1;
  97   1          P10 = 0;
  98   1          P11 = 0;
  99   1          P12 = 0;
 100   1          P13 = 0;
 101   1          P14 = 0;
 102   1          
 103   1      }
 104          
 105          unsigned char* getNumberDisplayFloat(float x, int displayLength, int precision){
 106   1          unsigned char value[8];
 107   1          unsigned char t[8];
 108   1          int value_len = 0;
 109   1          int set_flag = 0;
 110   1          int after_display = 0;
 111   1          int y, i, index;
 112   1          unsigned char a;
 113   1          if (precision == 0){
C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 00:55:44 PAGE 3   

 114   2              sprintf(value, "%.0f", x);
 115   2          }else if (precision == 1) {
 116   2              sprintf(value, "%.1f", x);
 117   2          }else if (precision == 2) {
 118   2              sprintf(value, "%.2f", x);
 119   2          }else if (precision == 3) {
 120   2              sprintf(value, "%.3f", x);
 121   2          }
 122   1          for(i=0; i<strlen(value);i++){
 123   2              if(value[i] == '.'){
 124   3                  break;
 125   3              }
 126   2              else{
 127   3                  value_len++;
 128   3              }
 129   2          }
 130   1          if((value_len + precision) > (displayLength)){
 131   2              // Display out of bound values on display
 132   2              return overflowHex;
 133   2          }
 134   1      
 135   1          for (i= strlen(value) - 1; i > -1; i--){
 136   2              y = strlen(value) - 1 - i;
 137   2              t[y] = value[i];
 138   2          }
 139   1          t[strlen(value)] = '\0';
 140   1          for(i=0;i < displayLength; i++) {
 141   2              final_display[i] = BLANK_HEX;
 142   2          }
 143   1          for(i=0;i < strlen(t); i++) {
 144   2              if(t[i]  == '.') {
 145   3                  set_flag = 1;
 146   3                  after_display = 1;
 147   3                  continue;
 148   3              }
 149   2              index = t[i] & 0x0f;
 150   2              a = no_digits[index];
 151   2              if(after_display == 1) {
 152   3                  if (set_flag == 1) {
 153   4                      a = 0x02 | a;
 154   4                      final_display[i-1] = a;
 155   4                      set_flag = 0;
 156   4                  }else{
 157   4                      final_display[i-1] = a;
 158   4                  }
 159   3              }else{
 160   3                  final_display[i] = a;
 161   3              }
 162   2              
 163   2          }
 164   1          final_display[6] = '\0';
 165   1          return final_display;
 166   1      }
 167          
 168          void joinCharacter(unsigned char* a, unsigned char* b) {
 169   1          int i = 0;
 170   1          while(a[i] != '\0') {
 171   2              i++;
 172   2          }
 173   1          a[i] = b[0];
 174   1          a[i+1] = '\0';
 175   1      }
C51 COMPILER V9.60.0.0   OM3                                                               09/08/2022 00:55:44 PAGE 4   

 176          
 177          void initializeDisplay() {
 178   1          TM1640_GPIO_Config();
 179   1          Keypad_GPIO_Config();
 180   1          TM1640_Init(DSPTM1640_DIS);     //TM1640 initialization
 181   1          Delay_Some_Time(10 );
 182   1      
 183   1          TM1640_U_display(blank_L);
 184   1          TM1640_M_display(blank_L);
 185   1          TM1640_L_display(blank_L);
 186   1      
 187   1          TM1640_U_display(prc);
 188   1          ldelay();
 189   1      
 190   1          TM1640_L_display(ver);
 191   1          ldelay();
 192   1      
 193   1          TM1640_L_display(blank_L);
 194   1          TM1640_U_display(blank_L);
 195   1          TM1640_M_display(blank_L);
 196   1          ldelay();
 197   1      
 198   1          TM1640_UM_display(compny_name);
 199   1          ldelay();
 200   1      
 201   1          TM1640_digichk(digi_chk);
 202   1          ldelay();
 203   1      
 204   1          TM1640_L_display(blank_L);
 205   1          TM1640_U_display(blank_L);
 206   1          TM1640_M_display(blank_L);
 207   1          ldelay();
 208   1          ldelay();
 209   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1270    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     79      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      52
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
