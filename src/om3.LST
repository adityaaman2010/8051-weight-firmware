C51 COMPILER V9.60.0.0   OM3                                                               09/05/2019 20:52:05 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OM3
OBJECT MODULE PLACED IN om3.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE om3.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "REG_MG82FG5Bxx.H"
   2          #include <stdio.h>
   3          #include <stdlib.h>
   4          #include <string.h>
   5          #include "macro.h"
   6          #include "utility.h"
   7          #include "tm1640.h"
   8          #include "keypad.h"
   9          #include "weight.h"
  10          
  11          
  12          
  13          void key_display(void);
  14          void Keypad_GPIO_Config(void);
  15          void key_sort(unsigned char);
  16          unsigned char* getNumberDisplay(unsigned char*, int, int);
  17          unsigned char* getCharArray(int);
  18          unsigned char* getNumberDisplayFloat(double, int, int);
  19          void initializeDisplay();
  20          
  21          unsigned char hi_key_no, lo_key_no;
  22          unsigned char xdata overflowHex[] = {0x10, 0x10, 0x10, 0x10, 0x10, 0x10};
  23          unsigned char xdata no_digits[] = {0xed,0xa0,0xd9,0xf8,0xb4,0x7c,0x7d,0xe0,0xfd,0xfc};  //0,1,2,3,4,5,6,7,8
             -,9
  24          unsigned char xdata digi_chk[] = {0x40,0xc0,0xe0,0xe8,0xe9,0xed,0xfd};
  25          unsigned char xdata prc[] = {0x00, 0x4d,0x45, 0xd5, 0x00};
  26          unsigned char xdata ver[] = { 0xed, 0xa2,0x00,0x45,0x5d, 0xad};
  27          unsigned char xdata compny_name[] = { 0xb5, 0x5d,0x0d, 0x0d, 0xed, 0x10, 0x7c, 0x4d, 0xf5,0x0d,0x00,0x00,0
             -x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  28          unsigned char xdata blank_L[] = { 0x00,0x00,0x00,0x00,0x00,0x00};
  29          unsigned char xdata bat_digi[] = { 0x00,0x1d, 0xf5, 0xfd,0x00};
  30          unsigned char xdata bat_voltg[] = { 0xb4,0xa2, 0xa0, 0x00,0x00};
  31          unsigned char xdata final_display[6];
  32          
  33          
  34          void main(void)
  35          {       double x;
  36   1          unsigned char key;
  37   1              double weight;
  38   1              double total;
  39   1              double currentPrice;
  40   1              unsigned char inputPrice[5];
  41   1              unsigned char* output;
  42   1              unsigned char temp[1];
  43   1              int precision = 2;
  44   1              initializeDisplay();
  45   1              output = getNumberDisplayFloat(22.5578, 5, 3);
  46   1              TM1640_U_display(output);
  47   1              output = getNumberDisplayFloat(2333.55, 5, 2);
  48   1              TM1640_M_display(output);
  49   1              output = getNumberDisplayFloat(99999.9, 6, 1);
  50   1              TM1640_L_display(output);
  51   1        while(1);
  52   1      //        TM1640_M_display(output);
  53   1      //        output = getNumberDisplayFloat(0.00, 5, precision);
C51 COMPILER V9.60.0.0   OM3                                                               09/05/2019 20:52:05 PAGE 2   

  54   1      //        TM1640_L_display(output);
  55   1      
  56   1      //    while(1)
  57   1      //    {
  58   1      //            weight = getWeight();
  59   1      //            output = getNumberDisplayFloat(weight, 5, precision);
  60   1      //            TM1640_U_display(output);
  61   1      //          
  62   1      //      key = scan_keypad();
  63   1      //      Delay_Some_Time(10);
  64   1      //      if(key != 'A') {
  65   1      //                if (key < 11) {
  66   1      //                    key = 0x30 | key;
  67   1      //                    temp[0] = key;
  68   1      //                    strcat(inputPrice, temp);
  69   1      //                    x = atof(inputPrice);
  70   1      //                    total = x * weight;
  71   1      //                    output = getNumberDisplay(inputPrice, 5, precision);
  72   1      //                    TM1640_M_display(output);
  73   1      //                    output = getNumberDisplayFloat(total, 6, precision);
  74   1      //                    TM1640_L_display(output);
  75   1      //                }
  76   1      //      }
  77   1      //      Delay_Some_Time(10);
  78   1      ////      key_display();
  79   1      //      Delay_Some_Time(100);
  80   1      //    }
  81   1          
  82   1      }
*** WARNING C280 IN LINE 35 OF om3.c: 'x': unreferenced local variable
*** WARNING C280 IN LINE 36 OF om3.c: 'key': unreferenced local variable
*** WARNING C280 IN LINE 37 OF om3.c: 'weight': unreferenced local variable
*** WARNING C280 IN LINE 38 OF om3.c: 'total': unreferenced local variable
*** WARNING C280 IN LINE 39 OF om3.c: 'currentPrice': unreferenced local variable
*** WARNING C280 IN LINE 40 OF om3.c: 'inputPrice': unreferenced local variable
*** WARNING C280 IN LINE 42 OF om3.c: 'temp': unreferenced local variable
  83          void Keypad_GPIO_Config(void)
  84          {
  85   1          P1M0 = 0x1f;
  86   1          P22 = 1;
  87   1          P24 = 1;
  88   1          P26 = 1;
  89   1          P16 = 1;
  90   1          P15 = 1;
  91   1          P10 = 0;
  92   1          P11 = 0;
  93   1          P12 = 0;
  94   1          P13 = 0;
  95   1          P14 = 0;
  96   1          
  97   1      }
  98          
  99          
 100          //unsigned char* getNumberDisplay(unsigned char* value, int displayLength, int precision){
 101          //    int value_len = 0;
 102          //    int set_flag = 0;
 103          //    int after_display = 0;
 104          //    int y, i, index;
 105          //    unsigned char t[sizeof(value)];
 106          //    unsigned char a;
 107          //    double x;
 108          //    x = atof(value);
C51 COMPILER V9.60.0.0   OM3                                                               09/05/2019 20:52:05 PAGE 3   

 109          //    if (precision == 0){
 110          //        sprintf(value, "%.0lf", x);
 111          //    }else if (precision == 1) {
 112          //        sprintf(value, "%.1lf", x);
 113          //    }else if (precision == 2) {
 114          //        sprintf(value, "%.2lf", x);
 115          //    }else if (precision == 3) {
 116          //        sprintf(value, "%.3lf", x);
 117          //    }
 118          //    TM1640_M_display(value);
 119          //    Delay_Some_Time(1000);
 120          //    for(i=0; i<sizeof(value);i++){
 121          //        if(value[i] == '.'){
 122          //            break;
 123          //        }
 124          //        else{
 125          //            value_len++;
 126          //        }
 127          //    }
 128          //    if((value_len + precision) > (displayLength)){
 129          //        // Display out of bound values on display
 130          //        return overflowHex;
 131          //    }
 132          
 133          //    for (i= sizeof(value)-1; i > -1; i--){
 134          //        y = sizeof(value) - 1 - i;
 135          //        t[y] = value[i];
 136          //    }
 137          //    for(i=0;i < displayLength; i++) {
 138          //        final_display[i] = BLANK_HEX;
 139          //    }
 140          //    for(i=0;i < sizeof(t); i++) {
 141          //        if(t[i] == '.') {
 142          //            set_flag = 1;
 143          //            after_display = 1;
 144          //            continue;
 145          //        }
 146          //        index = t[i] & 0x0f;
 147          //        a = no_digits[index];
 148          //        if(after_display == 1) {
 149          //            if (set_flag == 1) {
 150          //                final_display[i-1] = a | 0x02;
 151          //                set_flag = 0;
 152          //            }else{
 153          //                final_display[i-1] = a;
 154          //            }
 155          //        }else{
 156          //            final_display[i] = a;
 157          //        }
 158          //    }
 159          //    return final_display;
 160          //}
 161          
 162          unsigned char* getNumberDisplayFloat(double x, int displayLength, int precision){
 163   1          unsigned char value[8];
 164   1          unsigned char t[8];
 165   1          int value_len = 0;
 166   1          int set_flag = 0;
 167   1          int after_display = 0;
 168   1          int y, i, index;
 169   1          unsigned char a;
 170   1          if (precision == 0){
C51 COMPILER V9.60.0.0   OM3                                                               09/05/2019 20:52:05 PAGE 4   

 171   2              sprintf(value, "%.0f", x);
 172   2          }else if (precision == 1) {
 173   2              sprintf(value, "%.1f", x);
 174   2          }else if (precision == 2) {
 175   2              sprintf(value, "%.2f", x);
 176   2          }else if (precision == 3) {
 177   2              sprintf(value, "%.3f", x);
 178   2          }
 179   1          Delay_Some_Time(1000);
 180   1          for(i=0; i<strlen(value);i++){
 181   2              if(value[i] == '.'){
 182   3                  break;
 183   3              }
 184   2              else{
 185   3                  value_len++;
 186   3              }
 187   2          }
 188   1          if((value_len + precision) > (displayLength)){
 189   2              // Display out of bound values on display
 190   2              return overflowHex;
 191   2          }
 192   1      
 193   1          for (i= strlen(value) - 1; i > -1; i--){
 194   2              y = strlen(value) - 1 - i;
 195   2              t[y] = value[i];
 196   2          }
 197   1          t[strlen(value)] = '\0';
 198   1          for(i=0;i < displayLength; i++) {
 199   2              final_display[i] = BLANK_HEX;
 200   2          }
 201   1          for(i=0;i < strlen(t); i++) {
 202   2              if(t[i]  == '.') {
 203   3                  set_flag = 1;
 204   3                  after_display = 1;
 205   3                  continue;
 206   3              }
 207   2              index = t[i] & 0x0f;
 208   2              a = no_digits[index];
 209   2              if(after_display == 1) {
 210   3                  if (set_flag == 1) {
 211   4                      a = 0x02 | a;
 212   4                      final_display[i-1] = a;
 213   4                      set_flag = 0;
 214   4                  }else{
 215   4                      final_display[i-1] = a;
 216   4                  }
 217   3              }else{
 218   3                  final_display[i] = a;
 219   3              }
 220   2              
 221   2          }
 222   1          return final_display;
 223   1      }
 224          
 225          void initializeDisplay() {
 226   1          TM1640_GPIO_Config();
 227   1          Keypad_GPIO_Config();
 228   1          TM1640_Init(DSPTM1640_DIS);     //TM1640 initialization
 229   1          Delay_Some_Time(10 );
 230   1      
 231   1          TM1640_U_display(blank_L);
 232   1          TM1640_M_display(blank_L);
C51 COMPILER V9.60.0.0   OM3                                                               09/05/2019 20:52:05 PAGE 5   

 233   1          TM1640_L_display(blank_L);
 234   1      
 235   1          TM1640_U_display(prc);
 236   1          ldelay();
 237   1      
 238   1          TM1640_L_display(ver);
 239   1          ldelay();
 240   1      
 241   1          TM1640_L_display(blank_L);
 242   1          TM1640_U_display(blank_L);
 243   1          TM1640_M_display(blank_L);
 244   1          ldelay();
 245   1      
 246   1          TM1640_UM_display(compny_name);
 247   1          ldelay();
 248   1      
 249   1          TM1640_digichk(digi_chk);
 250   1          ldelay();
 251   1      
 252   1          TM1640_L_display(blank_L);
 253   1          TM1640_U_display(blank_L);
 254   1          TM1640_M_display(blank_L);
 255   1          ldelay();
 256   1      
 257   1          TM1640_U_display(bat_digi);
 258   1          TM1640_M_display(bat_voltg);
 259   1          ldelay();
 260   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    808    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     76    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      57
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
