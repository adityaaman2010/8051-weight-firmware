C51 COMPILER V9.60.0.0   OM3                                                               10/03/2022 16:11:56 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OM3
OBJECT MODULE PLACED IN .\build\Target 1\om3.o
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe .\OM3.C OMF2 TABS(4) CODE NOCOND SYMBOLS PRINT(.\build\Target 1\om3.lst)
                    - INCDIR(../../../../../../Keil_v5/C51/INC) DEFINE(__UVISION_VERSION=526) OPTIMIZE(8,SPEED) SMALL ROM(LARGE) OBJECT(.\bui
                    -ld\Target 1\om3.o)

line level    source

   1          #include <stdio.h>
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "REG_MG82FG5Bxx.H"
   5          #include "macro.h"
   6          #include "utility.h"
   7          #include "tm1640.h"
   8          #include "keypad.h"
   9          #include "weight.h"
  10          #include "memory.h"
  11          
  12          
  13          
  14          void key_display(void);
  15          void Keypad_GPIO_Config(void);
  16          void displayPrice(void);
  17          void addToInputPrice(void);
  18          void displayWeight(void);
  19          void handleModeOne(void);
  20          void loadMemory(void);
  21          void clearPrice(void);
  22          void handleNumberInput(void);
  23          void key_sort(unsigned char);
  24          unsigned char* getCharArray(int);
  25          unsigned char* getNumberDisplayFloat(float, int, int);
  26          void initializeDisplay();
  27          
  28          unsigned char xdata hi_key_no, lo_key_no;
  29          unsigned char xdata overflowHex[] = {0x10, 0x10, 0x10, 0x10, 0x10, 0x10};
  30          unsigned char xdata no_digits[] = {0xed,0xa0,0xd9,0xf8,0xb4,0x7c,0x7d,0xe0,0xfd,0xfc};  //0,1,2,3,4,5,6,7,8
             -,9
  31          unsigned char xdata digi_chk[] = {0x40,0xc0,0xe0,0xe8,0xe9,0xed,0xfd};
  32          unsigned char xdata prc[] = {0x00, 0x4d,0x45, 0xd5, 0x00};
  33          unsigned char xdata ver[] = { 0xed, 0xa2,0x00,0x45,0x5d, 0xad};
  34          unsigned char xdata compny_name[] = { 0xb5, 0x5d,0x0d, 0x0d, 0xed, 0x10, 0x7c, 0x4d, 0xf5,0x0d,0x00,0x00,0
             -x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  35          unsigned char xdata blank_L[] = { 0x00,0x00,0x00,0x00,0x00,0x00};
  36          unsigned char xdata bat_digi[] = { 0x00,0x1d, 0xf5, 0xfd,0x00};
  37          unsigned char xdata bat_voltg[] = { 0xb4,0xa2, 0xa0, 0x00,0x00};
  38          // flag to check if decimal mode activated
  39          int xdata isDecimal = 0,afterDecimal = 0;
  40          int xdata precision = 2, mode = 1, isOverflow = 0;
  41          float xdata weight, total, currentPrice;
  42          unsigned char xdata key, inputPrice[7], temp[1], output[8], final_display[7], savingTo;
  43          
  44          
  45          void main(void)
  46          {
  47   1          initializeDisplay();
  48   1          while(1)
  49   1          {
  50   2              weight = getWeight();
  51   2              key = scan_keypad();
C51 COMPILER V9.60.0.0   OM3                                                               10/03/2022 16:11:56 PAGE 2   

  52   2              Delay_Some_Time(10);
  53   2              if(key != 'A') {
  54   3                  isOverflow = (isDecimal == 1 && strlen(inputPrice) < 6) || ((isDecimal == 0 && strlen(inputPri
             -ce) + precision < 6) && key == 10) || (isDecimal == 0 && strlen(inputPrice) + precision < 5) ? 0 : 1;
  55   3                  if (mode == 1)
  56   3                  {
  57   4                      if (key == 16)
  58   4                      {
  59   5                          // set mode
  60   5                          mode = 2;
  61   5                          // default save to memory 1
  62   5                          savingTo = 17;
  63   5                          clearPrice();
  64   5                          displayPrice();
  65   5                          /*
  66   5                          TODO: set left side display
  67   5                          */
  68   5                          continue;
  69   5                      }
  70   4                      if (key > 16)
  71   4                      {
  72   5                          loadMemory();
  73   5                          continue;
  74   5                      }
  75   4                      
  76   4                      handleNumberInput();
  77   4                      displayWeight();
  78   4                      
  79   4                  }else if (mode == 2)
  80   3                  {
  81   4                      handleNumberInput();
  82   4                  }else if (mode == 3)
  83   3                  {
  84   4                      if (key == 11)
  85   4                      {
  86   5                          clearPrice();
  87   5                          mode = 1;
  88   5                          displayPrice();
  89   5                      }else if (key > 16)
  90   4                      {
  91   5                          loadMemory();
  92   5                      }
  93   4                      displayWeight();
  94   4                  }
  95   3                  
  96   3                  
  97   3              }
  98   2              Delay_Some_Time(10);
  99   2          }
 100   1              
 101   1      }
 102          
 103          void displayWeight(void)
 104          {
 105   1          output = getNumberDisplayFloat(weight, 5, precision);
*** ERROR C213 IN LINE 105 OF .\OM3.C: left side of asn-op not an lvalue
 106   1          TM1640_U_display(output);
 107   1      }
 108          
 109          void loadMemory(void)
 110          {
 111   1          float x = getPriceFromMemory(key);
C51 COMPILER V9.60.0.0   OM3                                                               10/03/2022 16:11:56 PAGE 3   

 112   1          if (x !== -1)
*** ERROR C141 IN LINE 112 OF .\OM3.C: syntax error near '=', expected 'sizeof'
 113   1          {
 114   2              // mode in which current price is immutable
 115   2              mode = 3;
 116   2              currentPrice = x;
 117   2              displayPrice();
 118   2          }
 119   1      }
 120          
 121          void handleNumberInput(void)
 122          {
 123   1          if ((key < 11 && isOverflow == 0) || key == 11)
 124   1          {
 125   2              handleModeOne();
 126   2          }
 127   1      }
 128          
 129          void handleModeOne(void)
 130          {
 131   1          if(key == 11)
 132   1          {
 133   2              clearPrice();
 134   2          }
 135   1          else if (key < 10 &&  isDecimal == 0)
 136   1          {
 137   2              addToInputPrice();
 138   2          }
 139   1          else if (key == 10 && isDecimal == 0)
 140   1          {
 141   2              isDecimal = 1;
 142   2              return;
 143   2          }
 144   1          else if (key < 10 &&  isDecimal == 1 && afterDecimal == 0)
 145   1          {
 146   2              // first number pressed after "."
 147   2              temp[0] = '.';
 148   2              joinCharacter(inputPrice, temp);
 149   2              key = 0x30 | key;
 150   2              temp[0] = key;
 151   2              joinCharacter(inputPrice, temp);
 152   2              afterDecimal = 1;
 153   2              currentPrice = atof(inputPrice);
 154   2          }
 155   1          else if (key < 10 &&  isDecimal == 1 && afterDecimal == 1)
 156   1          {
 157   2              addToInputPrice();
 158   2          }
 159   1          displayPrice();
 160   1      }
 161          
 162          void clearPrice(void)
 163          {
 164   1          inputPrice[0] = '\0';
 165   1          isDecimal = 0;
 166   1          afterDecimal = 0;
 167   1          currentPrice = 0.0;
 168   1      }
 169          
 170          void addToInputPrice(void)
 171          {
 172   1          key = 0x30 | key;
C51 COMPILER V9.60.0.0   OM3                                                               10/03/2022 16:11:56 PAGE 4   

 173   1          temp[0] = key;
 174   1          joinCharacter(inputPrice, temp);
 175   1          currentPrice = atof(inputPrice);
 176   1      }
 177          
 178          void displayPrice(void)
 179          {
 180   1          total = currentPrice * weight;
 181   1          output = getNumberDisplayFloat(currentPrice,5, precision);
 182   1          TM1640_M_display(output);
 183   1          output = getNumberDisplayFloat(total, 6, precision);
 184   1          TM1640_L_display(output);
 185   1      }
 186          
 187          void Keypad_GPIO_Config(void)
 188          {
 189   1              P1M0 = 0x1f;
 190   1              P22 = 1;
 191   1              P24 = 1;
 192   1              P26 = 1;
 193   1              P16 = 1;
 194   1              P15 = 1;
 195   1              P10 = 0;
 196   1              P11 = 0;
 197   1              P12 = 0;
 198   1              P13 = 0;
 199   1              P14 = 0;
 200   1              
 201   1      }
 202          
 203          unsigned char* getNumberDisplayFloat(float x, int displayLength, int precision)
 204          {
 205   1          unsigned char value[8];
 206   1          unsigned char t[8];
 207   1          int value_len = 0;
 208   1          int set_flag = 0;
 209   1          int after_display = 0;
 210   1          int y, i, index;
 211   1          unsigned char a;
 212   1          if (precision == 0)
 213   1          {
 214   2              sprintf(value, "%.0f", x);
 215   2          }
 216   1          else if (precision == 1)
 217   1          {
 218   2              sprintf(value, "%.1f", x);
 219   2          }
 220   1          else if (precision == 2)
 221   1          {
 222   2              sprintf(value, "%.2f", x);
 223   2          }
 224   1          else if (precision == 3)
 225   1          {
 226   2              sprintf(value, "%.3f", x);
 227   2          }
 228   1          for(i=0; i<strlen(value);i++)
 229   1          {
 230   2              if(value[i] == '.'){
 231   3                  break;
 232   3              }
 233   2              else{
 234   3                  value_len++;
C51 COMPILER V9.60.0.0   OM3                                                               10/03/2022 16:11:56 PAGE 5   

 235   3              }
 236   2          }
 237   1          if((value_len + precision) > (displayLength))
 238   1          {
 239   2              // Display out of bound values on display
 240   2              return overflowHex;
 241   2          }
 242   1      
 243   1          for (i= strlen(value) - 1; i > -1; i--)
 244   1          {
 245   2              y = strlen(value) - 1 - i;
 246   2              t[y] = value[i];
 247   2          }
 248   1          t[strlen(value)] = '\0';
 249   1          for(i=0;i < displayLength; i++)
 250   1          {
 251   2              final_display[i] = BLANK_HEX;
 252   2          }
 253   1          for(i=0;i < strlen(t); i++)
 254   1          {
 255   2              if(t[i]  == '.')
 256   2              {
 257   3                  set_flag = 1;
 258   3                  after_display = 1;
 259   3                  continue;
 260   3              }
 261   2              index = t[i] & 0x0f;
 262   2              a = no_digits[index];
 263   2              if(after_display == 1)
 264   2              {
 265   3                  if (set_flag == 1)
 266   3                  {
 267   4                      a = 0x02 | a;
 268   4                      final_display[i-1] = a;
 269   4                      set_flag = 0;
 270   4                  }
 271   3                  else
 272   3                  {
 273   4                      final_display[i-1] = a;
 274   4                  }
 275   3              }
 276   2              else
 277   2              {
 278   3                  final_display[i] = a;
 279   3              }
 280   2              
 281   2          }
 282   1          return final_display;
 283   1      }
 284          
 285          //void key_display(void)
 286          //{
 287          //    unsigned char temp[6];
 288          //    temp[0] = lo_key_no;
 289          //    temp[1] = hi_key_no;
 290          //    temp[2] = BLANK_HEX;
 291          //    temp[3] = BLANK_HEX;
 292          //    temp[4] = BLANK_HEX;
 293          //    temp[5] = BLANK_HEX;
 294          //    TM1640_L_display(temp);
 295          //
 296          //}
C51 COMPILER V9.60.0.0   OM3                                                               10/03/2022 16:11:56 PAGE 6   

 297          //void key_sort(unsigned char temp_key)
 298          //{
 299          //    if(temp_key <10)
 300          //    {
 301          //        hi_key_no = 0;
 302          //        lo_key_no = temp_key;
 303          //    }
 304          //    else
 305          //    {
 306          //        hi_key_no = temp_key/10;
 307          //        lo_key_no = temp_key%10;
 308          //    }
 309          //    hi_key_no = no_digits[hi_key_no];
 310          //    lo_key_no = no_digits[lo_key_no];
 311          //}
 312          
 313          void initializeDisplay()
 314          {
 315   1          TM1640_GPIO_Config();
 316   1          Keypad_GPIO_Config();
 317   1          TM1640_Init(DSPTM1640_DIS);         //TM1640 initialization
 318   1          Delay_Some_Time(10 );
 319   1      
 320   1          TM1640_U_display(blank_L);
 321   1          TM1640_M_display(blank_L);
 322   1          TM1640_L_display(blank_L);
 323   1      
 324   1          TM1640_U_display(prc);
 325   1          ldelay();
 326   1      
 327   1          TM1640_L_display(ver);
 328   1          ldelay();
 329   1      
 330   1          TM1640_L_display(blank_L);
 331   1          TM1640_U_display(blank_L);
 332   1          TM1640_M_display(blank_L);
 333   1          ldelay();
 334   1      
 335   1          TM1640_UM_display(compny_name);
 336   1          ldelay();
 337   1      
 338   1          TM1640_digichk(digi_chk);
 339   1          ldelay();
 340   1      
 341   1          TM1640_L_display(blank_L);
 342   1          TM1640_U_display(blank_L);
 343   1          TM1640_M_display(blank_L);
 344   1          ldelay();
 345   1          ldelay();
 346   1      
 347   1          output = getNumberDisplayFloat(0, 5, 2);
 348   1          TM1640_M_display(output);
 349   1          output = getNumberDisplayFloat(0, 6, precision);
 350   1          TM1640_L_display(output);
 351   1          loadPricesFromMemory();
 352   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  2 ERROR(S)
